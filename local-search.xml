<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/07/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p> <img src="/2022/07/09/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.jpg" class="" title="图片引用方法一"> ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go基础</title>
    <link href="/2022/07/09/%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/09/%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数组、切片和映射"><a href="#数组、切片和映射" class="headerlink" title="数组、切片和映射"></a>数组、切片和映射</h1><p>数组、切片和映射</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><em>数组是一个长度固定的数据类型，是一段具有相同类型元素的连续块</em>。</p><h3 id="声明和初始化数组"><a href="#声明和初始化数组" class="headerlink" title="声明和初始化数组"></a>声明和初始化数组</h3><p>一般用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> array [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>      <span class="hljs-comment">//默认初始化为0</span><br></code></pre></td></tr></table></figure><p>使用数组字面值声明数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">array := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;<br>array := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;  <span class="hljs-comment">//数组的容量由初始化值得数量决定。</span><br></code></pre></td></tr></table></figure><p>声明数组并指定特定位置的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">array := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">10</span>, <span class="hljs-number">2</span>: <span class="hljs-number">20</span>&#125;   <span class="hljs-comment">//array[1]=10, array[2]=20, 其余等于0</span><br></code></pre></td></tr></table></figure><p>一旦声明，数组里存储的数据类型和数组长度就都不可以改变了。当数组初始化时，数组每个元素都初始化为对应类型的零值。</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>一般用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">array[<span class="hljs-number">3</span>] = <span class="hljs-number">35</span><br></code></pre></td></tr></table></figure><p><strong>数组间的赋值是值拷贝</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明第一个包含 5 个元素的字符串数组</span><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><span class="hljs-comment">// 声明第二个包含 5 个元素的字符串数组</span><br>array2 := [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-string">&quot;Yellow&quot;</span>, <span class="hljs-string">&quot;Pink&quot;</span>&#125;<br><span class="hljs-comment">// 把 array2 的值复制到 array1</span><br>array1 = array2<br></code></pre></td></tr></table></figure><p><strong>数组变量的类型包括数组长度和每个元素的类型，只有这两部分都相同的数组才能进行赋值，也叫类型相同的数组</strong></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//声明一个默认初始化的二维数组</span><br><span class="hljs-keyword">var</span> array [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">//使用数组字面量来声明并初始化一个二维整型数组</span><br>array := [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]&#123;&#123;<span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">20</span>, <span class="hljs-number">21</span>&#125;, &#123;<span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;, &#123;<span class="hljs-number">40</span>, <span class="hljs-number">41</span>&#125;&#125;<br><span class="hljs-comment">// 声明并初始化外层数组中索引为 1 个和 3 的元素</span><br>array := [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: &#123;<span class="hljs-number">20</span>, <span class="hljs-number">21</span>&#125;, <span class="hljs-number">3</span>: &#123;<span class="hljs-number">40</span>, <span class="hljs-number">41</span>&#125;&#125;<br><span class="hljs-comment">// 声明并初始化外层数组和内层数组的单个元素</span><br>array := [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: &#123;<span class="hljs-number">0</span>: <span class="hljs-number">20</span>&#125;, <span class="hljs-number">3</span>: &#123;<span class="hljs-number">1</span>: <span class="hljs-number">41</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明两个不同的二维整型数组</span><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> array2 [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">// 将 array2 的值复制给 array1</span><br>array1 = array2<br><br><span class="hljs-comment">// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里</span><br><span class="hljs-keyword">var</span> array3 [<span class="hljs-number">2</span>]<span class="hljs-type">int</span> = array1[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">// 将外层数组的索引为 1、内层数组的索引为 0 的整型值复制到新的整型变量里</span><br><span class="hljs-keyword">var</span> value <span class="hljs-type">int</span> = array1[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是围绕动态数组的概念构建的，可以按需增长和缩小。声明切片和声明数组的不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建有 3 个元素的整型数组</span><br>array := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;<br><span class="hljs-comment">// 创建长度和容量都是 3 的整型切片</span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><p>**如果在[]运算符里指定了一个值，那么创建的就是数组而不是切片。只有不指定值的时候，才会创建切片  **</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>切片是对底层数组进行了抽象。每个切片包含三个字段：</p><ol><li><p>指向底层数组的指针</p></li><li><p>切片访问元素的个数（长度）</p></li><li><p>切片允许增长到的元素个数（容量）</p><img src="C:\Users\nibing\AppData\Roaming\Typora\typora-user-images\image-20200922214043374.png" alt="切片内部实现" style="zoom:80%;" /></li></ol><p><strong>在函数间传递切片相当于是传递24个字节（64位），指针8字节，长度和容量分别8字节</strong></p><h3 id="创建和初始化切片"><a href="#创建和初始化切片" class="headerlink" title="创建和初始化切片"></a>创建和初始化切片</h3><ol><li><p>使用字面值创建切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建字符串切片，其长度和容量都是 5 个元素</span><br>slice := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-string">&quot;Yellow&quot;</span>, <span class="hljs-string">&quot;Pink&quot;</span>&#125;<br><span class="hljs-comment">// 创建一个整型切片，其长度和容量都是 3 个元素</span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;<br><span class="hljs-comment">// 创建字符串切片，使用空字符串初始化第 100 个元素，此时切片的长度和容量都是100</span><br>slice := []<span class="hljs-type">string</span>&#123;<span class="hljs-number">99</span>: <span class="hljs-string">&quot;&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用make方式创建切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个字符串切片，其长度和容量都是 5 个元素</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment">// 创建一个整型切片，其长度为 3 个元素，容量为 5 个元素</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure></li><li><p>使用三个索引创建切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建字符串切片，其长度和容量都是 5 个元素</span><br>source := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Grape&quot;</span>&#125;<br><span class="hljs-comment">// 将第三个元素切片，并限制容量，其长度为 1 个元素，容量为 2 个元素</span><br>slice := source[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>注意这里的容量是2</strong></p></li><li><p>nil和空切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//声明时不做任何初始化创建的就是nil切片</span><br><span class="hljs-keyword">var</span> slice []<span class="hljs-type">int</span><br><span class="hljs-comment">//创建空切片</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment">// 使用 make 创建空的整型切片</span><br>slice := []<span class="hljs-type">int</span>&#123;&#125;   <span class="hljs-comment">// 使用切片字面量创建空的整型切片</span><br></code></pre></td></tr></table></figure></li><li><p>根据切片创建切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个整型切片，其长度和容量都是 5 个元素</span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;<br><span class="hljs-comment">// 创建一个新切片，其长度为 2 个元素，容量为 4 个元素</span><br>newSlice := slice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><img src="C:\Users\nibing\AppData\Roaming\Typora\typora-user-images\image-20200923100206286.png" alt="共享同一数组的两个切片" style="zoom:80%;" /></li></ol><h3 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h3><h4 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h4><p>要使用append函数， 需要一个被操作的切片和一个要追加的值。当append返回时，会返回一个包含修改结果的新切片。append函数总是会增加新切片的长度，而容量不一定会被改变，这取决于被操作的切片的可用容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个整型切片，其长度和容量都是 5 个元素</span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;<br><span class="hljs-comment">// 创建一个新切片，其长度为 2 个元素，容量为 4 个元素</span><br>newSlice := slice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br><span class="hljs-comment">// 使用原有的容量来分配一个新元素，将新元素赋值为 60</span><br>newSlice = <span class="hljs-built_in">append</span>(newSlice, <span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><img src="https://i.loli.net/2020/09/23/StWsxFYMl14THdn.png" alt="image-20200923103808950" style="zoom:80%;" /><p><strong>如果切片的底层数组没有足够的可用容量，append函数会创建一个新的底层数组，并将原有的数组拷贝过去。在切片的容量小于1000个元素时，总是会成倍的增加容量，一旦元素个数超过1000，容量的增长因子为1.25，也就是每次增加25%。随着语言的演化，这个增长算法可能会改变</strong></p><p>函数append是一个可变参数的函数，这意味着可以在一次调用传递多个追加的值。如果使用…运算符，可以将一个切片的所有元素都追加到另一个切片中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建两个切片，并分别用两个整数进行初始化</span><br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-comment">// 将两个切片追加在一起，并显示结果</span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, <span class="hljs-built_in">append</span>(s1, s2...))<br>Output:<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h4 id="range关键字"><a href="#range关键字" class="headerlink" title="range关键字"></a>range关键字</h4><p><strong>range创建了每个元素的副本，而不是返回对该元素的引用</strong>。关键词range总是会从切片头部开始遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;<br><br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> slice &#123;     <span class="hljs-comment">// 迭代每一个元素，并显示其值</span><br>fmt.Printf(<span class="hljs-string">&quot;Index: %d Value: %d\n&quot;</span>, index, value)<br>&#125;<br><br><span class="hljs-comment">//使用空白标识符（下划线）来忽略索引值</span><br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> slice &#123;     <span class="hljs-comment">// 迭代每个元素，并显示其值</span><br>fmt.Printf(<span class="hljs-string">&quot;Value: %d\n&quot;</span>, value)<br>&#125;<br><br><span class="hljs-comment">//使用传统的for循环对切片进行遍历</span><br><span class="hljs-keyword">for</span> index := <span class="hljs-number">2</span>; index &lt; <span class="hljs-built_in">len</span>(slice); index++ &#123;    <span class="hljs-comment">// 从第三个元素开始迭代每个元素</span><br>fmt.Printf(<span class="hljs-string">&quot;Index: %d Value: %d\n&quot;</span>, index, slice[index])<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个整型切片的切片</span><br>slice := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;&#125;  <span class="hljs-comment">//得到一个包含两个元素的外层切片，每个元素包含一个内层的整型切片。</span><br><span class="hljs-comment">// 为第一个切片追加值为 20 的元素</span><br>slice[<span class="hljs-number">0</span>] = <span class="hljs-built_in">append</span>(slice[<span class="hljs-number">0</span>], <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><strong>映射是一个存储键值对的无序集合，底层使用散列表来进行存储。map是引用类型，在函数间传递map并不会发生拷贝。</strong></p><h3 id="map中的重点"><a href="#map中的重点" class="headerlink" title="map中的重点"></a>map中的重点</h3><ul><li><p>map中的key必须是支持&#x3D;&#x3D;比较运算符的数据类型</p></li><li><p>map中的元素并不是一个变量，所以不能对map的元素进行取址操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">_ = &amp;ages[<span class="hljs-string">&quot;bob&quot;</span>] <span class="hljs-comment">// compile error: cannot take address of map element</span><br></code></pre></td></tr></table></figure><p>这是因为map可能随着元素数量的增长而导致重新分配内存，这样原来的地址就失效了。</p></li><li><p>map的遍历顺序是不确定的，不同的哈希函数实现可能导致不同的遍历顺序。如果要顺序遍历，可以先取出所有的key、对key排序、再遍历。</p></li><li><p>通过key作为索引来访问map将产生一个value，如果key存在，返回对应的value，如果key不存在，则返回对应value的零值。那如何判断一个已存在的0和一个因不存在而返回零值的0呢？（例如value是int类型）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">age, ok := ages[<span class="hljs-string">&quot;bob&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123; <span class="hljs-comment">/* &quot;bob&quot; is not a key in this map; age == 0 */</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p>map的零值是nil。在向map存元素前必须先创建map（也就是map不能为nil），但是读元素的时候map可以是nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span> <span class="hljs-comment">//此时mp为nil</span><br>mp[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-literal">true</span>     <span class="hljs-comment">//编译错误，产生一个panic异常。panic: assignment to entry in nil map</span><br>v, ok := mp[<span class="hljs-string">&quot;hello&quot;</span>]   <span class="hljs-comment">//这是可以运行的，此时v和ok都是false</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="创建和初始化映射"><a href="#创建和初始化映射" class="headerlink" title="创建和初始化映射"></a>创建和初始化映射</h3><p>在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中键值对的数目。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个映射，键的类型是 string，值的类型是 int</span><br>dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 创建一个映射，键和值的类型都是 string</span><br><span class="hljs-comment">// 使用两个键值对初始化映射</span><br>dict := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Red&quot;</span>: <span class="hljs-string">&quot;#da1337&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>: <span class="hljs-string">&quot;#e95a22&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>创建映射时，更常用的方法是使用映射字面量。映射的初始长度会根据初始化时指定的键值对的数量来确定。  <em>映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值可以使用&#x3D;&#x3D;运算符做比较</em>。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误 。</p><h3 id="使用映射"><a href="#使用映射" class="headerlink" title="使用映射"></a>使用映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//为映射赋值</span><br>colors := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;   <span class="hljs-comment">// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码</span><br>colors[<span class="hljs-string">&quot;Red&quot;</span>] = <span class="hljs-string">&quot;#da1337&quot;</span>   <span class="hljs-comment">// 将 Red 的代码加入到映射</span><br><br><span class="hljs-comment">//对nil映射赋值时会导致运行错误</span><br><span class="hljs-keyword">var</span> colors <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>        <span class="hljs-comment">// 通过声明映射创建一个 nil 映射</span><br>colors[<span class="hljs-string">&quot;Red&quot;</span>] = <span class="hljs-string">&quot;#da1337&quot;</span>          <span class="hljs-comment">// 将 Red 的代码加入到映射</span><br><br>Runtime Error:<br><span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: assignment to entry in <span class="hljs-literal">nil</span> <span class="hljs-keyword">map</span><br></code></pre></td></tr></table></figure><p>从映射中获取值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//从映射获取值并判断键是否存在</span><br>value, exists := colors[<span class="hljs-string">&quot;Blue&quot;</span>]   <span class="hljs-comment">// 获取键 Blue 对应的值</span><br><span class="hljs-keyword">if</span> exists &#123;     <span class="hljs-comment">//这个键存在吗？</span><br>fmt.Println(value)<br>&#125;<br><br><span class="hljs-comment">//从映射中获取值，并通过该值判断键是否存在。这种方法只能用在映射存储的值都是非零值的情况</span><br>value := colors[<span class="hljs-string">&quot;Blue&quot;</span>]  <span class="hljs-comment">// 获取键 Blue 对应的值</span><br><span class="hljs-keyword">if</span> value != <span class="hljs-string">&quot;&quot;</span> &#123;       <span class="hljs-comment">// 这个键存在吗？</span><br>fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用range遍历映射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 显示映射里的所有颜色</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> colors &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Key: %s Value: %s\n&quot;</span>, key, value)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用内置函数delete删除映射中的键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除键为 Coral 的键值对</span><br><span class="hljs-built_in">delete</span>(colors, <span class="hljs-string">&quot;Coral&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>说白了就是用于表示值或者类型的代码段。比如：<strong>1234就是代表整数值的字面量，int64就是代表类型的字面量</strong>。很简单，不用想的太复杂。</p><h2 id="不可寻址的对象有："><a href="#不可寻址的对象有：" class="headerlink" title="不可寻址的对象有："></a>不可寻址的对象有：</h2><ol><li><strong>不可变的</strong>值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。</li><li>绝大多数被视为<strong>临时结果</strong>的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。</li><li>若拿到某值的指针可能会破坏程序的一致性，那么就是<strong>不安全的</strong>，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li></ol><h2 id="语法糖：结构体字面量可取地址"><a href="#语法糖：结构体字面量可取地址" class="headerlink" title="语法糖：结构体字面量可取地址"></a>语法糖：结构体字面量可取地址</h2><ol><li>如果一个结构体对象是可寻址的，那么它的字段也是可寻址的；反之，如果一个结构体对象是不可寻址的，那么它的字段也是不可寻址的。而不可寻址的字段的值是不可更改的，<strong>结构体字面量是不可寻址的。</strong></li></ol> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>Pages <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">var</span> book = Book&#123;&#125; <span class="hljs-comment">// 变量值book是可寻址的</span><br>p := &amp;book.Pages<br>*p = <span class="hljs-number">123</span><br>fmt.Println(book) <span class="hljs-comment">// &#123;123&#125;</span><br><br><span class="hljs-comment">// 下面这两行编译不通过，因为Book&#123;&#125;是不可寻址的，继而Book&#123;&#125;.Pages也是不可寻址的。</span><br><span class="hljs-comment">// Book&#123;&#125;.Pages = 123</span><br><span class="hljs-comment">// p = &amp;Book&#123;&#125;.Pages // &lt;=&gt; p = &amp;(Book&#123;&#125;.Pages)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：属性选择操作符<code>.</code>的优先级比取地址操作符<code>&amp;</code>的优先级要高。</p><ol start="2"><li><strong>一般来说，只有可被寻址的值才能被取地址</strong>，但是Go中有一个语法糖（语法例外）：虽然所有的结构体字面量都是不可寻址的，但是它们都可被取地址。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>Pages <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Book&#123;100&#125;是不可寻址的，但是它可以被取地址。</span><br>p := &amp;Book&#123;<span class="hljs-number">100</span>&#125; <span class="hljs-comment">// &lt;=&gt; tmp := Book&#123;100&#125;; p := &amp;tmp</span><br>p.Pages = <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：是结构体字面量可以被取地址，结构体临时对象是不可取地址的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>d.name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> Dog &#123;<br><span class="hljs-keyword">return</span> Dog&#123;name&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>(&amp;Dog&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;).SetName(<span class="hljs-string">&quot;hi&quot;</span>) <span class="hljs-comment">// 可以编译通过，取结构体字面量的地址</span><br>(&amp;New(<span class="hljs-string">&quot;ni&quot;</span>)).SetName(<span class="hljs-string">&quot;hi&quot;</span>)    <span class="hljs-comment">// 不可以编译通过，因为取结构体临时对象的地址</span><br>  New(<span class="hljs-string">&quot;haha&quot;</span>).SetName(<span class="hljs-string">&quot;hi&quot;</span>)     <span class="hljs-comment">// 不可以编译通过，和上面情况一样</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h3 id="声明和定义一个结构体"><a href="#声明和定义一个结构体" class="headerlink" title="声明和定义一个结构体"></a>声明和定义一个结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    firstName <span class="hljs-type">string</span>  <span class="hljs-comment">// firstName, lastName  string</span><br>    lastName  <span class="hljs-type">string</span><br>    age       <span class="hljs-type">int</span><br>&#125;<br><br>emp := Employee&#123;       <span class="hljs-comment">//其中字段不需要按照声明的顺序进行初始化</span><br>    firstName : <span class="hljs-string">&quot;ni&quot;</span>,<br>    age       : <span class="hljs-number">24</span>,<br>    lastName  : <span class="hljs-string">&quot;bing&quot;</span>,<br>&#125;<br><span class="hljs-comment">//or</span><br>emp := Employee&#123;<span class="hljs-string">&quot;ni&quot;</span>, <span class="hljs-string">&quot;bing&quot;</span>, <span class="hljs-number">24</span>&#125;   <span class="hljs-comment">//其中字段必须按照声明的顺序初始化</span><br><span class="hljs-comment">//使用new</span><br>emp := <span class="hljs-built_in">new</span>(Employee)<br>emp.firstName = <span class="hljs-string">&quot;ni&quot;</span><br>emp.age       = <span class="hljs-number">24</span><br>emp.lastName  = <span class="hljs-string">&quot;bing&quot;</span><br><span class="hljs-comment">//使用取地址</span><br>emp := &amp;Employee&#123;<span class="hljs-string">&quot;ni&quot;</span>, <span class="hljs-string">&quot;bing&quot;</span>, <span class="hljs-number">24</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">emp := <span class="hljs-keyword">struct</span> &#123;<br>    firstName  <span class="hljs-type">string</span><br>    lastName   <span class="hljs-type">string</span><br>    age        <span class="hljs-type">int</span><br>&#125;&#123;<br>    firstName : <span class="hljs-string">&quot;ni&quot;</span>,<br>    lastName  : <span class="hljs-string">&quot;bing&quot;</span>,<br>    age       : <span class="hljs-number">24</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">emp.firstName<br>emp.lastName<br>emp.age<br>若emp是指针类型，比如：<br>emp := &amp;Employee&#123;<span class="hljs-string">&quot;ni&quot;</span>, <span class="hljs-string">&quot;bing&quot;</span>, <span class="hljs-number">24</span>&#125;<br>那么可以用emp.firstName来代替(*emp).firstName<br></code></pre></td></tr></table></figure><h3 id="结构体零值"><a href="#结构体零值" class="headerlink" title="结构体零值"></a>结构体零值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> emp Employee  <span class="hljs-comment">//zero value struct</span><br>此时结构体中各个字段是其类型的零值<br></code></pre></td></tr></table></figure><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">string</span><br>    <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">//匿名字段的默认名称是其类型名</span><br>p := Person&#123;<br>    <span class="hljs-type">string</span> : <span class="hljs-string">&quot;nibing&quot;</span>,<br>    <span class="hljs-type">int</span>    : <span class="hljs-number">24</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;  <br>    city  <span class="hljs-type">string</span><br>    state <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;  <br>    name    <span class="hljs-type">string</span><br>    age     <span class="hljs-type">int</span><br>    address Address<br>&#125;<br><br>p := Person&#123;<br>    name    : <span class="hljs-string">&quot;nibing&quot;</span>,<br>    age     : <span class="hljs-number">24</span>,<br>    address : Address&#123;<br>        city  : <span class="hljs-string">&quot;wuhan&quot;</span>,<br>        state : <span class="hljs-string">&quot;hubei&quot;</span>,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体嵌入"><a href="#结构体嵌入" class="headerlink" title="结构体嵌入"></a>结构体嵌入</h3><p>若Person类型和Address类型都有一个Print()方法，那么当定义一个Person对象然后调用Print方法时，调用的是Person的Print方法，<strong>因为只要名称相同，无论两个方法的签名（参数和返回类型）是否一致，被嵌入类型（外层类型）的方法都会屏蔽掉嵌入字段（内层类型）的同名方法。类似的，两个类型中的同名字段遵循相同的规则。即使一个是字段，一个是方法，也遵循相同规则。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//只有当结构体作为匿名字段时才可以进行提升</span><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;  <br>    city  <span class="hljs-type">string</span><br>    state <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>    Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    p := Person&#123;<br>        name: <span class="hljs-string">&quot;Naveen&quot;</span>,<br>        age:  <span class="hljs-number">50</span>,<br>        Address: Address&#123;<br>            city:  <span class="hljs-string">&quot;Chicago&quot;</span>,<br>            state: <span class="hljs-string">&quot;Illinois&quot;</span>,<br>        &#125;,<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Name:&quot;</span>, p.name)<br>    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, p.age)<br>    fmt.Println(<span class="hljs-string">&quot;City:&quot;</span>, p.city)   <span class="hljs-comment">//city is promoted field</span><br>    fmt.Println(<span class="hljs-string">&quot;State:&quot;</span>, p.state) <span class="hljs-comment">//state is promoted field</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体导出"><a href="#结构体导出" class="headerlink" title="结构体导出"></a>结构体导出</h3><p>当结构体名称的第一个字母是大写的时候这个结构体是可导出的，当结构体中字段的第一个字母是大写的时候这个字段是可导出的，否则不可导出。</p><h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p>当结构体中的所有字段都是可比较的，那么这个结构体就是可比较的。当同类型的两个结构体变量中各个字段都是相等的，这两个结构体变量才是相等的。</p><h1 id="方法、接口和反射"><a href="#方法、接口和反射" class="headerlink" title="方法、接口和反射"></a>方法、接口和反射</h1><p>Go 语言是一种静态类型的编程语言。这意味着编译器需要在编译时知晓程序里每个值的类型。如果提前知道类型信息，编译器就可以确保程序合理地使用值。这有助于减少潜在的内存异常和 bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。  </p><p><strong>值的类型给编译器提供了两部分信息：需要分配多少内存给这个值（值的规模）和这段内存表示什么。</strong></p><p><strong>Go语言将数据类型分为4类：基础类型、复合类型、引用类型和接口类型。</strong></p><ul><li>基础类型：数字、字符串、布尔值</li><li>复合类型：数组、结构体。通过组合简单类型，来表达更加复杂的数据结构。</li><li>引用类型：指针、切片、字典、函数、通道。都是对一个变量或状态的间接引用。</li><li>接口类型：</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法类似于c++中的成员函数。关键字func和函数名之间的参数被称为接收者，如果一个函数有接收者，这个函数就被称为方法。</p><p><strong>可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者接口。类型和其定义的方法可以不在一个文件当中，但是必须在同一个包中</strong></p><p>Go语言有两种类型的接收者：值接收者和指针接收者；这两者被调用时发生的都是值传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-type">string</span><br>    email <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-comment">//notify使用值接收者实现了一个方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u user)</span></span> notify() &#123;<br>    <br>&#125;<br><span class="hljs-comment">//changeEmail使用指针接收者实现了一个方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *user)</span></span> changeEmail(email <span class="hljs-type">string</span>) &#123;<br>    <br>&#125;<br><br><br>bill := user&#123;<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-string">&quot;bill@email.com&quot;</span>&#125;<br>lisa := &amp;user&#123;<span class="hljs-string">&quot;Lisa&quot;</span>, <span class="hljs-string">&quot;lisa@email.com&quot;</span>&#125;<br><br>bill.notify()  <span class="hljs-comment">//方法notify会接收到bill值的一个副本（拷贝）</span><br>lisa.notyfy()  <span class="hljs-comment">//相当于(*lisa).notify()，传递过去的是lisa指针指向的值的一个副本（拷贝）</span><br><br>lisa.changeEmail(<span class="hljs-string">&quot;lisa@newdomain.com&quot;</span>) <span class="hljs-comment">//使用指针接收者的方法，传递过去的lisa这个地址值</span><br>bill.changeEmail(<span class="hljs-string">&quot;bill@newdomain.com&quot;</span>) <span class="hljs-comment">//相当于(&amp;bill).changeEmail(&quot;bill@newdomain.com&quot;)，传递过去的是bill地址值</span><br></code></pre></td></tr></table></figure><p>方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。下面这种也可以定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IP []<span class="hljs-type">byte</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ip IP)</span></span>MarshalText() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="理解值方法和指针方法"><a href="#理解值方法和指针方法" class="headerlink" title="理解值方法和指针方法"></a>理解值方法和指针方法</h3><p>假如我们定义了一个Cat结构体<code>type Cat struct&#123;&#125;</code>，那么Cat是一个类型，*Cat也是一个类型（Cat的指针类型）。<strong>这时，<code>Cat</code>可以被叫做<code>*Cat</code>的基本类型</strong>。</p><p>然后我们为Cat这个类定义两个方法，一个值接收者，一个指针接收者。注意，<strong>Cat这个基本类型的方法集合中只会包含它的值接收者方法，不包含指针接收者方法。但是，*Cat的方法集合中即包含值接收者方法，又包含指针接收者方法，因为*Cat的基本类型是Cat</strong>。理解了这一点也就理解了下面这一点：（<strong>当我们把一个类型的对象赋值给接口对象时，这个类型必须是实现了接口的所有方法。</strong>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;  <br>    Describe()<br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Describe() &#123; <span class="hljs-comment">//implemented using value receiver  </span><br>    fmt.Printf(<span class="hljs-string">&quot;%s is %d years old\n&quot;</span>, p.name, p.age)<br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;  <br>    state   <span class="hljs-type">string</span><br>    country <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Address)</span></span> Describe() &#123; <span class="hljs-comment">//implemented using pointer receiver  </span><br>    fmt.Printf(<span class="hljs-string">&quot;State %s Country %s&quot;</span>, a.state, a.country)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> d1 Describer<br>    p1 := Person&#123;<span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-number">25</span>&#125;<br>    d1 = p1   <span class="hljs-comment">// 可以赋值，因为p1的类型Person实现了接口的方法</span><br>    d1.Describe()<br>    p2 := Person&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-number">32</span>&#125;<br>    d1 = &amp;p2  <span class="hljs-comment">// 可以赋值，因为&amp;p2的类型*Person实现了接口的方法</span><br>    d1.Describe()<br><br>    <span class="hljs-keyword">var</span> d2 Describer<br>    a := Address&#123;<span class="hljs-string">&quot;Washington&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>&#125;<br>    <span class="hljs-comment">/* compilation error if the following line is</span><br><span class="hljs-comment">       uncommented</span><br><span class="hljs-comment">       cannot use a (type Address) as type Describer</span><br><span class="hljs-comment">       in assignment: Address does not implement</span><br><span class="hljs-comment">       Describer (Describe method has pointer</span><br><span class="hljs-comment">       receiver)</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//d2 = a  // 不能赋值，因为a的类型Address没有实现接口的方法，Address类型的方法集合中只包含值接收者方法</span><br>    d2 = &amp;a   <span class="hljs-comment">// 可以赋值，因为&amp;a的类型*Address实现了接口的方法</span><br>    d2.Describe()<br>&#125;<br></code></pre></td></tr></table></figure><p>严格来讲， 我们在Cat这样的基本类型的值上只能调用其值接收者方法，之所以可以调用指针接收者方法，是因为go编译器帮我们做了转换<code>(&amp;cat).xxx()</code>。即：先取<code>cat</code>的指针值，然后在该指针值上调用某个方法。</p><p>那么上面的<code>d2 = a</code>为什么不帮我们做自动转换呢？因为类型完整性（取地址不安全），见下面<code>接口</code>那节的内容。</p><h3 id="方法作为值和参数"><a href="#方法作为值和参数" class="headerlink" title="方法作为值和参数"></a>方法作为值和参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  a <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> <span class="hljs-built_in">print</span>(message <span class="hljs-type">string</span>) &#123;<br>  fmt.Println(message, t.a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> hello(message <span class="hljs-type">string</span>) &#123;<br>  fmt.Println(<span class="hljs-string">&quot;Hello!&quot;</span>, message)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callMethod</span><span class="hljs-params">(t T, method <span class="hljs-keyword">func</span>(T, <span class="hljs-type">string</span>)</span></span>) &#123;<br>  method(t, <span class="hljs-string">&quot;A message&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  t1 := T&#123;<span class="hljs-number">10</span>&#125;<br>  t2 := T&#123;<span class="hljs-number">20</span>&#125;<br>  <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(T, <span class="hljs-type">string</span>)</span></span> = T.<span class="hljs-built_in">print</span>  <span class="hljs-comment">//方法作为值。注意T.print的类型是func(T, string)</span><br>  callMethod(t1, f)<br>  callMethod(t2, f)<br>  callMethod(t1, T.hello)         <span class="hljs-comment">//方法作为参数。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Go中，接口是一系列方法的签名，当一个type实现了接口的所有方法时，就说这个type实现了这个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Namer <span class="hljs-keyword">interface</span> &#123;<br>    Method1(param_list) return_type<br>    ...<br>&#125;<br><br><span class="hljs-comment">//定义一个空接口</span><br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">56</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">type</span> ei <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">var</span> s ei<br>s := <span class="hljs-number">56</span><br></code></pre></td></tr></table></figure><h3 id="接口的内存模型"><a href="#接口的内存模型" class="headerlink" title="接口的内存模型"></a>接口的内存模型</h3><p>当我们给一个接口变量赋值的时候，接口变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中，这个专用的数据结构就叫做iface。</p><p>iface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。其中，类型信息会由另一个专用数据结构的实例来承载，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。此外，指向动态值的指针并不是指向赋值的那个变量，而是指向赋值变量的副本，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pet <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Category() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Dog实现了Pet接口，并且有一个SetName方法</span><br>dog := Dog&#123;<span class="hljs-string">&quot;little pig&quot;</span>&#125;<br><span class="hljs-keyword">var</span> pet Pet = dog<br>dog.SetName(<span class="hljs-string">&quot;monster&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时pet变量的字段name的值依然是”little pig“。因为将dog赋值给pet，是通过值传递。因此pet的动态值是dog的一个副本。</p><h4 id="接口变量的值在什么情况下才为nil？"><a href="#接口变量的值在什么情况下才为nil？" class="headerlink" title="接口变量的值在什么情况下才为nil？"></a>接口变量的值在什么情况下才为nil？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> dog *Dog       <span class="hljs-comment">// dog为nil</span><br><span class="hljs-keyword">var</span> pet Pet = dog  <span class="hljs-comment">// pet不为nil</span><br></code></pre></td></tr></table></figure><p>此时，dog的值为nil，但是pet不为nil。因为pet的iface结构包含两部分，一个是类型信息，一个是动态值。pet的动态值是nil，但是pet的动态类型不是nil，而是*Dog。也就是说，这时Go语言会识别出赋予pet的值是一个*Dog类型的nil，然后Go 语言就会用一个<code>iface</code>的实例包装它，包装后的产物肯定就不是<code>nil</code>了。</p><p>那什么情况下接口变量的值才是nil呢？答案是：要么只声明它但不做初始化，要么直接把字面量<code>nil</code>赋给它（这种情况下这个nil是无类型的）。</p><h3 id="接口的嵌入"><a href="#接口的嵌入" class="headerlink" title="接口的嵌入"></a>接口的嵌入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWrite <span class="hljs-keyword">interface</span> &#123;<br>  Read(b Buffer) <span class="hljs-type">bool</span><br>  Write(b Buffer) <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Lock <span class="hljs-keyword">interface</span> &#123;<br>  Lock()<br>  Unlock()<br>&#125;<br><br><span class="hljs-keyword">type</span> File <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">//File接口相当于拥有上面两个接口的所有方法，此外还包含Close方法</span><br>  ReadWrite<br>  Lock<br>  Close()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口类型间的嵌入不会设计方法的屏蔽，只有组合的接口中有同名的方法， 即使方法的签名不同，就会产生冲突，无法编译。</strong></p><p>go语言团队鼓励我们声明体量较小的接口，然后通过接口间的组合&#x2F;嵌入来扩展程序、增加程序的灵活性。</p><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>没有方法的接口就是空接口，用interface{}表示。因为空接口没有任何方法，因此所有的类型自然的就实现了空接口。空接口可以作为函数参数，用来接收任意类型的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    fmt.Printf(<span class="hljs-string">&quot;Type = %T, value = %v\n&quot;</span>, i, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    s := <span class="hljs-string">&quot;Hello World&quot;</span><br>    describe(s)<br>    i := <span class="hljs-number">55</span><br>    describe(i)<br>    strt := <span class="hljs-keyword">struct</span> &#123;<br>        name <span class="hljs-type">string</span><br>    &#125;&#123;<br>        name: <span class="hljs-string">&quot;Naveen R&quot;</span>,<br>    &#125;<br>    describe(strt)<br>&#125;<br><br>输出：<br>Type = <span class="hljs-type">string</span>, value = Hello World  <br>Type = <span class="hljs-type">int</span>, value = <span class="hljs-number">55</span>  <br>Type = <span class="hljs-keyword">struct</span> &#123; name <span class="hljs-type">string</span> &#125;, value = &#123;Naveen R&#125;  <br></code></pre></td></tr></table></figure><h3 id="类型断言（type-assertion）"><a href="#类型断言（type-assertion）" class="headerlink" title="类型断言（type assertion）"></a>类型断言（type assertion）</h3><p>类型断言用来抽取出接口底层的值，也就是(type, value)中的value。若有一个接口<code>i</code>，其指向的值的类型为<code>T</code>，则<code>i.(T)</code>可获取到这个值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    s := i.(<span class="hljs-type">int</span>) <span class="hljs-comment">//get the underlying int value from i</span><br>    fmt.Println(s)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">56</span><br>    assert(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上面代码中将56改为“hello”，也就是将int改为string，那么i.(int)将产生一个panic：<code>interface conversion: interface &#123;&#125; is string, not int</code></p><p>解决办法是使用<code>v, ok := i.(T)</code>如果接口i的底层类型是T，那么v将得到其值，并且ok为true；否则v为T的零值并且ok为false，这种情况下不会产生panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    v, ok := i.(<span class="hljs-type">int</span>)<br>    fmt.Println(v, ok)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">56</span><br>    assert(s)<br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Steven Paul&quot;</span><br>    assert(i)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findType</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    <span class="hljs-keyword">switch</span> i.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        fmt.Printf(<span class="hljs-string">&quot;I am a string and my value is %s\n&quot;</span>, i.(<span class="hljs-type">string</span>))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        fmt.Printf(<span class="hljs-string">&quot;I am an int and my value is %d\n&quot;</span>, i.(<span class="hljs-type">int</span>))<br>    <span class="hljs-keyword">default</span>:<br>        fmt.Printf(<span class="hljs-string">&quot;Unknown type\n&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    findType(<span class="hljs-string">&quot;Naveen&quot;</span>)<br>    findType(<span class="hljs-number">77</span>)<br>    findType(<span class="hljs-number">89.98</span>)<br>&#125;<br><br>输出：<br>I am a <span class="hljs-type">string</span> and my value is Naveen  <br>I am an <span class="hljs-type">int</span> and my value is <span class="hljs-number">77</span>  <br>Unknown <span class="hljs-keyword">type</span>  <br></code></pre></td></tr></table></figure><p>还可以用来获取一个type所实现的接口，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;  <br>    Describe()<br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Describe() &#123;  <br>    fmt.Printf(<span class="hljs-string">&quot;%s is %d years old&quot;</span>, p.name, p.age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findType</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    <span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> Describer:<br>        v.Describe()<br>    <span class="hljs-keyword">default</span>:<br>        fmt.Printf(<span class="hljs-string">&quot;unknown type\n&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    findType(<span class="hljs-string">&quot;Naveen&quot;</span>)<br>    p := Person&#123;<br>        name: <span class="hljs-string">&quot;Naveen R&quot;</span>,<br>        age:  <span class="hljs-number">25</span>,<br>    &#125;<br>    findType(p)<br>&#125;<br><br>输出：<br>unknown <span class="hljs-keyword">type</span>  <br>Naveen R is <span class="hljs-number">25</span> years old  <br></code></pre></td></tr></table></figure><h3 id="接口调用值接收者和指针接收者方法"><a href="#接口调用值接收者和指针接收者方法" class="headerlink" title="接口调用值接收者和指针接收者方法"></a>接口调用值接收者和指针接收者方法</h3><table><thead><tr><th align="center">接口中方法的接收者</th><th align="center">接口底层所指向的对象(type, value)中的value</th></tr></thead><tbody><tr><td align="center">（t T）</td><td align="center">T and *T</td></tr><tr><td align="center">（t *T）</td><td align="center">*T</td></tr></tbody></table><p>我们知道，在方法中，对于值接收者方法或者指针接收者方法，都是既可以接收值对象，也可以接收指针对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> name() &#123;<br>  fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span></span> age() &#123;<br>  fmt.Println(<span class="hljs-string">&quot;10&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  dog    := Dog&#123;&#125;<br>  dogPtr := &amp;Dog&#123;&#125;<br>  <br>  dog.name()<br>  dog.age()      <span class="hljs-comment">// (&amp;dog).age()</span><br>  <br>  dogPtr.name()  <span class="hljs-comment">// (*dogPtr).name()</span><br>  dogPtr.age()<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在接口中，当接收者为指针时，是不能接收值对象的，这是为什么呢？</p><p>这是因为当把一个对象赋值给接口后，是无法通过这个接口来获取这个对象的地址，因此在通过接口调用指针接收者方法时，也就不能进行取地址操作了。</p><p>那么为什么不能通过接口来获取其动态值的地址呢？这是为了保持类型的完整性。可见<a href="https://stackoverflow.com/questions/48790663/why-value-stored-in-an-interface-is-not-addressable-in-golang">https://stackoverflow.com/questions/48790663/why-value-stored-in-an-interface-is-not-addressable-in-golang</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">type</span> A <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> B <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> a A = <span class="hljs-number">5</span><br>  <span class="hljs-keyword">var</span> i I = a<br>  fmt.Printf(<span class="hljs-string">&quot;i is of type %T\n&quot;</span>, i)<br>  <br>  <span class="hljs-comment">// 假设我们可以获取一个储存在接口里面的值的地址</span><br>  <span class="hljs-keyword">var</span> aPtr *A<br>  aPtr = &amp;(i.(A)) <span class="hljs-comment">// not allowed, but if it were...</span><br>  <br>  <span class="hljs-comment">// 接着我们创建一个B类型的对象并且赋值给接口</span><br>  <span class="hljs-keyword">var</span> b B = <span class="hljs-string">&quot;hello&quot;</span><br>  i = b<br>  fmt.Printf(<span class="hljs-string">&quot;i is of type %T, aPtr is of type %T\n&quot;</span>, i, aPtr)<br>&#125;<br><br><span class="hljs-comment">// input:</span><br><span class="hljs-comment">// i is of type main.A</span><br><span class="hljs-comment">// i is of type main.B, aPtr is of type *main.A</span><br></code></pre></td></tr></table></figure><p>在将<code>b</code>赋值给接口对象<code>i</code>之后，<code>aptr</code>指向什么呢？aptr本来是指向对象a的，但是把b赋值给接口i之后，aptr就不再是一个有效的指针了。因此，在第12行，不能获取接口的动态值的地址，因为这是不安全的。</p><p>当把一个非指针对象赋值给一个接口后，然后这个接口调用了一个指针接收者方法，那么此时就要取这个非指针对象的地址值才行（就像结构体的方法一样）。然而又不能获取接口的动态值的地址，所以…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;  <br>    Describe()<br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Describe() &#123; <span class="hljs-comment">//implemented using value receiver  </span><br>    fmt.Printf(<span class="hljs-string">&quot;%s is %d years old\n&quot;</span>, p.name, p.age)<br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;  <br>    state   <span class="hljs-type">string</span><br>    country <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Address)</span></span> Describe() &#123; <span class="hljs-comment">//implemented using pointer receiver  </span><br>    fmt.Printf(<span class="hljs-string">&quot;State %s Country %s&quot;</span>, a.state, a.country)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> d1 Describer<br>    p1 := Person&#123;<span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-number">25</span>&#125;<br>    d1 = p1<br>    d1.Describe()<br>    p2 := Person&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-number">32</span>&#125;<br>    d1 = &amp;p2<br>    d1.Describe()<br><br>    <span class="hljs-keyword">var</span> d2 Describer<br>    a := Address&#123;<span class="hljs-string">&quot;Washington&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>&#125;<br><br>    <span class="hljs-comment">/* compilation error if the following line is</span><br><span class="hljs-comment">       uncommented</span><br><span class="hljs-comment">       cannot use a (type Address) as type Describer</span><br><span class="hljs-comment">       in assignment: Address does not implement</span><br><span class="hljs-comment">       Describer (Describe method has pointer</span><br><span class="hljs-comment">       receiver)</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//d2 = a</span><br><br>    d2 = &amp;a <span class="hljs-comment">//This works since Describer interface</span><br>    <span class="hljs-comment">//is implemented by Address pointer in line 22</span><br>    d2.Describe()<br>&#125;<br><br>输出：<br>Sam is <span class="hljs-number">25</span> years old  <br>James is <span class="hljs-number">32</span> years old  <br>State Washington Country USA <br></code></pre></td></tr></table></figure><h3 id="接口的零值"><a href="#接口的零值" class="headerlink" title="接口的零值"></a>接口的零值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;  <br>    Describe()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> d1 Describer<br>    <span class="hljs-keyword">if</span> d1 == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;d1 is nil and has type %T value %v\n&quot;</span>, d1, d1)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//d1 is nil and has type &lt;nil&gt; value &lt;nil&gt; </span><br><span class="hljs-comment">//如果使用d1.Describe()，将产生一个panic</span><br></code></pre></td></tr></table></figure><p>想要使接口变量的值为nil，可以通过只声明但不初始化，或者直接把字面量nil赋给他。<strong>但有一点要注意，当把一个值为nil的结构体赋值给接口变量时，接口变量的值并不是nil，这是因为接口变量包含了值和类型，这种情况下，值为nil，但是类型是该结构体类型。</strong></p><h3 id="接口对象间的赋值"><a href="#接口对象间的赋值" class="headerlink" title="接口对象间的赋值"></a>接口对象间的赋值</h3><p>一个接口对象可以赋值给另一个接口对象，只要实现了被赋值接口中的方法。可以将任何对象赋值给空接口。</p><p>比如有两个接口对象，a和b。a &#x3D; b；只要b的底层数据实现了a接口中的方法就可以。</p><h3 id="map-string-interface"><a href="#map-string-interface" class="headerlink" title="map[string] interface{}"></a>map[string] interface{}</h3><p>使用map时，将interface{}作为map中值就可以存储任何类型，但是之后在使用这些值之前需要先进行类型断言。</p><h3 id="将interface嵌入struct中"><a href="#将interface嵌入struct中" class="headerlink" title="将interface嵌入struct中"></a>将interface嵌入struct中</h3><p>此时可以将struct对象赋值给接口，尽管struct没有实现该接口。如果想要通过赋值后的对象调用接口中的函数， 只能调用该结构体已经实现了的方法，无论该方法是否是接口中的函数。</p><p><a href="https://www.jianshu.com/p/a5bc8add7c6e">https://www.jianshu.com/p/a5bc8add7c6e</a></p><h2 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h2><p>不能进行取地址的操作有：</p><ol><li>不可变的值不可寻址。如常量、基本类型的字面量等。</li><li>大多数的临时值。如算术操作的结果值等。</li><li>地址不安全的值。如果拿到某值的地址可能会破坏程序的一致性，那么就是不安全的，也就不可寻址了。比如字典、c++中的vector扩容后导致原地址失效的情况，等等。</li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是在程序运行期间检查对象的值并找到其类型的能力。</p><h3 id="为啥需要反射"><a href="#为啥需要反射" class="headerlink" title="为啥需要反射"></a>为啥需要反射</h3><p>当我们在程序中定义好变量后，其类型和值都已经确定了，为什么还需要在程序运行期间对其进行检查&#x2F;获取呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;  <br>    ordId      <span class="hljs-type">int</span><br>    customerId <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> employee <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>    id <span class="hljs-type">int</span><br>    address <span class="hljs-type">string</span><br>    salary <span class="hljs-type">int</span><br>    country <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;  <span class="hljs-comment">//该函数的作用是根据入参创建一条sql的插入语句并返回</span><br>    <span class="hljs-comment">//若传入order对象，则   insert into order values (1234, 567)  </span><br>    <span class="hljs-comment">//若传入employee对象，则insert into employee values(&quot;Naveen&quot;, 565, &quot;Science Park Road, Singapore&quot;, 90000, &quot;Singapore&quot;)  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如何根据createQuery函数的不同入参返回不同的insert语句呢？这种情况下就要用到反射！可以通过反射检查<code>q</code>这个空接口底层对象的值和类型。</p><h3 id="reflect-Type和reflect-Value"><a href="#reflect-Type和reflect-Value" class="headerlink" title="reflect.Type和reflect.Value"></a>reflect.Type和reflect.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;  <br>    ordId      <span class="hljs-type">int</span><br>    customerId <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    t := reflect.TypeOf(q)     <span class="hljs-comment">//返回reflect.Type</span><br>    v := reflect.ValueOf(q)    <span class="hljs-comment">//返回reflect.Value</span><br>    fmt.Println(<span class="hljs-string">&quot;Type &quot;</span>, t)    <span class="hljs-comment">//Type  main.order  </span><br>    fmt.Println(<span class="hljs-string">&quot;Value &quot;</span>, v)   <span class="hljs-comment">//Value  &#123;456 56&#125;  </span><br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    o := order&#123;<br>        ordId:      <span class="hljs-number">456</span>,<br>        customerId: <span class="hljs-number">56</span>,<br>    &#125;<br>    createQuery(o)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reflect-Kind"><a href="#reflect-Kind" class="headerlink" title="reflect.Kind"></a>reflect.Kind</h3><p>Kind和Type都是返回对象的类型，但区别如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;  <br>    ordId      <span class="hljs-type">int</span><br>    customerId <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    t := reflect.TypeOf(q)<br>    k := t.Kind()<br>    fmt.Println(<span class="hljs-string">&quot;Type &quot;</span>, t)   <span class="hljs-comment">//Type  main.order </span><br>    fmt.Println(<span class="hljs-string">&quot;Kind &quot;</span>, k)   <span class="hljs-comment">//Kind  struct  </span><br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    o := order&#123;<br>        ordId:      <span class="hljs-number">456</span>,<br>        customerId: <span class="hljs-number">56</span>,<br>    &#125;<br>    createQuery(o)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NumField-和Field-方法"><a href="#NumField-和Field-方法" class="headerlink" title="NumField()和Field()方法"></a>NumField()和Field()方法</h3><p>NumField()返回一个struct对象的字段个数，Field(i)返回一个struct对象中第<code>i</code>个字段值（reflect.Value）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;  <br>    ordId      <span class="hljs-type">int</span><br>    customerId <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;  <br>    <span class="hljs-keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;<br>        v := reflect.ValueOf(q)<br>        fmt.Println(<span class="hljs-string">&quot;Number of fields&quot;</span>, v.NumField())<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;Field:%d type:%T value:%v\n&quot;</span>, i, v.Field(i), v.Field(i))<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    o := order&#123;<br>        ordId:      <span class="hljs-number">456</span>,<br>        customerId: <span class="hljs-number">56</span>,<br>    &#125;<br>    createQuery(o)<br>&#125;<br><span class="hljs-comment">//Number of fields 2  </span><br><span class="hljs-comment">//Field:0 type:reflect.Value value:456  </span><br><span class="hljs-comment">//Field:1 type:reflect.Value value:56  </span><br></code></pre></td></tr></table></figure><h1 id="channel和Goroutines"><a href="#channel和Goroutines" class="headerlink" title="channel和Goroutines"></a>channel和Goroutines</h1><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel可以理解为goroutines用来通信的管道，数据从一端发送，另一端接收。<strong>这里要注意的细节是：元素值从外界进入通道时会被复制，也就是说进入通道的不是在接收操作符右边的那个元素，而是其副本。从通道中取出数据包含两步，第一步是生成通道中元素的副本并给到接收方，第二步是删除通道中对应的元素</strong></p><p><strong>对于非缓冲通道，一开始执行发送&#x2F;接收操作都会被阻塞，直到配对的操作（接收&#x2F;发送）也开始执行才会继续传递，然后继续运行。</strong></p><p><strong>通道是引用类型，当只声明而没有使用make初始化通道时其值为nil。对nil通道执行发送&#x2F;接收操作都会永久的处于阻塞状态。</strong></p><p><strong>声明一个channel</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>   <span class="hljs-comment">//a是一个空值（nil）</span><br></code></pre></td></tr></table></figure><p><strong>短变量声明</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p><strong>读写channel</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">data := &lt;- a <span class="hljs-comment">//从channel中读取数据</span><br>a &lt;- <span class="hljs-number">10</span>      <span class="hljs-comment">//写入数据到channel中</span><br></code></pre></td></tr></table></figure><p>在未设置容量的channel中，发送和接收数据默认是阻塞的。也就是说，发送一个数据到channel中将会带来阻塞，直到有其他的Goroutinues从channel中取出这个数据。反过来也是一样的。</p><h3 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h3><p><strong>单向通道的作用通常是约束其他代码的行为，其一般出现在函数的参数列表或者返回列表中。双向通道可以直接赋值给单向通道，其间发生了隐式转换，但是反过来是不可以的。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sendch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)  <span class="hljs-comment">//sendch只能写入，不能读出</span><br>recvch := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <span class="hljs-comment">//recvch只能读出，不能写入</span><br><br></code></pre></td></tr></table></figure><h3 id="关闭channel和range-channel"><a href="#关闭channel和range-channel" class="headerlink" title="关闭channel和range channel"></a>关闭channel和range channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v, ok := &lt;- ch <span class="hljs-comment">//当ch这个channel关闭后，并且channel中的数据为空时，ok返回false，v为ch中类型的零值。</span><br></code></pre></td></tr></table></figure><p><strong>当close一个buffer channel时，如果channel中有还有数据没读完，那么仍然可以继续读取，并且ok返回true。当数据读完后，v为元素类型的零值，ok返回false；如果是无buffer的channel，那么close后v为元素类型的零值，ok返回false。</strong></p><p><strong>对channel使用for range是一直循环读取到这个channel关闭，如果channel没有关闭或者channel值为nil，那么会一直阻塞下去。不管是否是buffer channel，都可以对其使用for range进行读取。</strong></p><p><em>注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是<code>true</code>（为false表示通道关闭）。因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事</em></p><p><em>其实并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。）</em></p><p><strong>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常，试图向一个已关闭的channel中继续发送数据也将导致panic异常。关闭一个channels还会触发一个广播机制。</strong></p><h4 id="优雅关闭channel"><a href="#优雅关闭channel" class="headerlink" title="优雅关闭channel"></a>优雅关闭channel</h4><p><a href="https://gfw.go101.org/article/channel-closing.html">https://gfw.go101.org/article/channel-closing.html</a></p><h3 id="使用for-range-channel时的一个坑"><a href="#使用for-range-channel时的一个坑" class="headerlink" title="使用for range channel时的一个坑"></a>使用for range channel时的一个坑</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanIn</span><span class="hljs-params">(chs ...<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> chs &#123;         <span class="hljs-comment">// 注释这里是错误的，因为这样导致所有的协程共用了一个channel，也就是ch对象</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;      <span class="hljs-comment">// go func() &#123;</span><br>c &lt;- &lt;- in           <span class="hljs-comment">// c &lt;- &lt;- ch</span><br>    &#125;(ch)                          <span class="hljs-comment">// &#125;()</span><br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="buffer-channel"><a href="#buffer-channel" class="headerlink" title="buffer channel"></a>buffer channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">type</span>, capacity)<br></code></pre></td></tr></table></figure><p>向buffer发送数据只有当buffer满时才会发生阻塞，同样的，从buffer读数据只有当buffer为空时才阻塞。<strong>当发生阻塞时，通道会通知最早等待发送&#x2F;接收操作而阻塞的goroutine。</strong></p><p>buffer channel的capacity是使用make创建时指定的，为channel最多容纳的元素个数。length是channel当前拥有的元素个数。</p><h3 id="！channel的广播机制"><a href="#！channel的广播机制" class="headerlink" title="！channel的广播机制"></a>！channel的广播机制</h3><p><strong>channel被close后，仍然可以读取</strong>，不但可以读取出已发送的数据，还可以不断的读取零值，但是如果通过range读取，channel关闭后for循环会跳出。因此使用channel的close特性，可以实现广播功能。</p><p>通过<code>i, ok := &lt;-ch</code>可以查看channel的状态。</p><p>如果一个channel中没有数据了，此时关闭channel仍然可以读取出channel类型的零值，并且第二个返回值是false，代表channel关闭了。</p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup&#123;&#125; <span class="hljs-comment">//创建一个零值的WaitGroup（结构体类型）</span><br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">//计数器加1</span><br>wg.Done() <span class="hljs-comment">//计数器减1</span><br>wg.Wait() <span class="hljs-comment">//阻塞，直到计数器数值为0</span><br><span class="hljs-comment">//在使用wg这个变量时，如果要进行函数间的传递，需要传递wg的地址值，不能进行值传递。</span><br></code></pre></td></tr></table></figure><p><strong>waitgroup的计数器的值不可以为负数，否则会发生panic。此外，不要把Add操作和Wait操作放在不同的goroutine中同时执行，这会导致panic，但是不容易复现。</strong></p><h2 id="Goroutinue"><a href="#Goroutinue" class="headerlink" title="Goroutinue"></a>Goroutinue</h2><p>协程是<em><strong>非抢占式</strong></em>多任务处理，由协程主动交出控制权，这也就是说理论上一个协程如果不主动让出CPU，那么其就一直运行下去直到结束。但是Goroutinue和传统意义上的协程不一样的是调度器会控制协程间的切换，因此虽然协程是非抢占式的，但是何时交出控制权并不完全是由程序员控制的，Go的调度器会在合适的点进行切换，比如*(只是参考)*I&#x2F;O、Select、等待锁、函数调用(有时)等等。程序员控制的切换有runtime.Gosched()。</p><p>协程是编译器、解释器、虚拟机层面的多任务，对于操作系统而言是没有协程的存在的。</p><p>多个协程可能在<strong>一个或多个线程</strong>上运行，这取决于Go语言的调度器。</p><p><img src="https://i.loli.net/2021/06/04/3F9J4a1Z7HSfEIX.png" alt="image-20210604105137309"></p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>select是专为通道设计的，每个case语句都只能包含通道操作的表达式。select语句被用于从多个send&#x2F;receive Channel操作中选择一个。Select语句会阻塞，直到多个Channel的读&#x2F;写操作中有一个或多个就绪，如果有多个就绪，那么会随机的选择一个。</p><p><strong>注意：读&#x2F;写操作就绪是指这个读&#x2F;写操作是可以正常读取出或者正常写入的，不会发生阻塞。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>    time.Sleep(<span class="hljs-number">6</span> * time.Second)<br>    ch &lt;- <span class="hljs-string">&quot;from server1&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>    time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>    ch &lt;- <span class="hljs-string">&quot;from server2&quot;</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    output2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> server1(output1)<br>    <span class="hljs-keyword">go</span> server2(output2)<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> s1 := &lt;-output1:<br>        fmt.Println(s1)<br>    <span class="hljs-keyword">case</span> s2 := &lt;-output2:<br>        fmt.Println(s2)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出 from server2 后程序结束</span><br></code></pre></td></tr></table></figure><h3 id="Default-Case"><a href="#Default-Case" class="headerlink" title="Default Case"></a>Default Case</h3><p>defaule case一般被用于防止select语句发送阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>    time.Sleep(<span class="hljs-number">10500</span> * time.Millisecond)<br>    ch &lt;- <span class="hljs-string">&quot;process successful&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> process(ch)<br>    <span class="hljs-keyword">for</span> &#123;<br>        time.Sleep(<span class="hljs-number">1000</span> * time.Millisecond)<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> v := &lt;-ch:<br>            fmt.Println(<span class="hljs-string">&quot;received value: &quot;</span>, v)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;no value received&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//该程序打印10次“no value received”，最后打印一次“received value: process successful”</span><br></code></pre></td></tr></table></figure><p><strong>当在for循环中使用select语句时，并且在select语句的分支中加入break语句，那么只会结束当前select语句的执行，不会对外层的for循环产生影响。</strong></p><h3 id="select使用注意事项"><a href="#select使用注意事项" class="headerlink" title="select使用注意事项"></a>select使用注意事项</h3><p><code>select</code>语句包含的候选分支中的<code>case</code>表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在<code>select</code>语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。</p><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mutex.Lock()  <br>x = x + <span class="hljs-number">1</span>  <br>mutex.Unlock()  <br></code></pre></td></tr></table></figure><p><strong>If one Goroutine already holds the lock and if a new Goroutine is trying to acquire a lock, the new Goroutine will be blocked until the mutex is unlocked.</strong></p><p><strong>使用channel也可以实现类似Mutex的效果，比如：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>)<br>ch &lt;- <span class="hljs-literal">true</span><br>x = x + <span class="hljs-number">1</span><br>&lt;- ch<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Go语言为我们提供了测试框架，但是使用这个框架，需要遵循如下几个原则：</p><ol><li><strong>文件名</strong>：含有单元测试代码的Go文件必须以_test.go结尾，Go语言测试工具只认这个结尾的文件。单元测试文件名test.go前面的部分最好是被测试的方法所在go文件的文件名。</li><li><strong>函数名</strong>：单元测试的函数名必须是Test开头，可选的后缀名必须是大写开头。最好是Test+要测试的函数名(如TestAdd，表示要测试Add这个函数)</li><li><strong>函数参数和返回值</strong>：单元测试的函数必须接收一个指向testing.T类型的指针作为参数，并且不返回任何值。func TestName(t *testing.T)  {}</li></ol><p><em><strong>go test命令行：</strong></em></p><p>不加参数 <code>go test .</code>就是运行当前目录下所有的测试文件</p><p><code>-v</code>参数可用于打印每个测试函数的名字和运行时间</p><p><code>-run</code>对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行。如：<code>go test -v -run=&quot;French|Canal&quot;</code></p><p><em><strong>测试函数注意事项</strong></em></p><p>失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。<strong>即使前面的数据导致了测试的失败，后面的测试数据依然会运行测试</strong>，因此在一个测试中我们可能了解多个失败的信息。</p><p>如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。</p><p>测试失败的信息一般的形式是“f(x) &#x3D; y, want z”，其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。</p><h2 id="传统测试和表格驱动测试"><a href="#传统测试和表格驱动测试" class="headerlink" title="传统测试和表格驱动测试"></a>传统测试和表格驱动测试</h2><h3 id="传统测试"><a href="#传统测试" class="headerlink" title="传统测试"></a>传统测试</h3><p><img src="https://i.loli.net/2021/06/06/wOQZxqpIMD2aT4u.png" alt="image-20210606215132318"><strong>缺点：</strong>1.测试数据和测试逻辑混在一起；2.出错信息不明确；3.一旦一个数据出错测试全部结束。</p><h3 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testint.T)</span></span> &#123;<br>    tests := []<span class="hljs-keyword">struct</span>&#123;<br>    a,b,c <span class="hljs-type">int32</span><br>&#125;&#123;<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests&#123;<br>    <span class="hljs-keyword">if</span> actual := Add(tt.a, tt.b); actual != tt.c &#123;<br>            t.Errorf(<span class="hljs-string">&quot;Add(%d,%d);&quot;</span> + <span class="hljs-string">&quot;got %d; expected %d&quot;</span>, tt.a, tt.b, actual, tt.c)<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong>1.分离测试数据和测试逻辑；2.明确的出错信息；3.可以部分失败。</p><h2 id="性能测试-x2F-基准测试"><a href="#性能测试-x2F-基准测试" class="headerlink" title="性能测试&#x2F;基准测试"></a>性能测试&#x2F;基准测试</h2><p><strong>命令：</strong>go test -bench .</p><p>性能测试是测试一个程序在固定工作负载下的性能。在Go语言中，性能测试和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个<code>*testing.B</code>类型的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkAdd</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    a, b, c := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">//性能测试不需要多个case</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;   <span class="hljs-comment">//性能测试需要测试多次</span><br>        actual := Add(a, b)<br>        <span class="hljs-keyword">if</span> actual != c &#123;<br>            b.Errorf(<span class="hljs-string">&quot;Add(%d,%d);&quot;</span> + <span class="hljs-string">&quot;got %d; expected %d&quot;</span>, a, b, actual, c)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p>1.文件名同样和测试用的一样<code>xxx_test.go</code></p><p>2.函数名为func Example<u>Add</u>() {}</p><p><strong>案例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleQueue_Pop</span><span class="hljs-params">()</span></span> &#123;<br>q := Queue&#123;<span class="hljs-number">1</span>&#125;<br>q.Push(<span class="hljs-number">2</span>)<br>q.Push(<span class="hljs-number">3</span>)<br>fmt.Println(q.Pop())<br>fmt.Println(q.Pop())<br>fmt.Println(q.IsEmpty())<br><br>fmt.Println(q.Pop())<br>fmt.Println(q.IsEmpty())<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// false</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>上面代码中的注释是必须要写的，否则提示<code>no test to run</code>。<strong>注释的写法为：第一行是<code>Output:</code>；接下来每行为一个输出。</strong></p><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>1.在GoLand中选择Run XXX with Coverage</p><p>2.在命令行中键入go test -cover</p><h3 id="统计单个包的覆盖率"><a href="#统计单个包的覆盖率" class="headerlink" title="统计单个包的覆盖率"></a>统计单个包的覆盖率</h3><ol><li>go test -coverprofile&#x3D;c.out</li><li>go tool cover -html&#x3D;c.out （在网页中展示覆盖的分析结果）</li></ol><h3 id="统计整个项目的覆盖率"><a href="#统计整个项目的覆盖率" class="headerlink" title="统计整个项目的覆盖率"></a>统计整个项目的覆盖率</h3><ol><li>go test -v -coverprofile&#x3D;c.out -coverpkg .&#x2F;… .&#x2F;… （项目根目录下所有的包）</li><li>go tool cover -func&#x3D;c.out -o c.txt   （统计结果在c.txt文件里，这种方式可以看到整个项目的覆盖率数值）</li></ol><h2 id="GoMock"><a href="#GoMock" class="headerlink" title="GoMock"></a>GoMock</h2><p>使用gomock一般分为以下四步：</p><ol><li><p>使用<code>mockgen</code>为想要mock的接口生成mock</p></li><li><p>在测例中，创建 <code>gomock.Controller</code> 实例，并且将其作为参数传递给mock对象的构造器中以获得mock对象。然后通过defer调用 <code>Finish()</code> 断言设置的预期行为被调用</p></li><li><p>调用 <code>EXPECT()</code>设置预期行为</p></li><li><p>编写单元测试逻辑</p></li></ol><p><strong>局限性</strong>：首先，依赖的方法必须是在一个interface中，这样才能改变被测函数中调用依赖的行为。其次，被测函数需要采用依赖注入的方法（接口对象在参数列表中）编写，不然没办法将mock的接口传递给被测函数。</p><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><p>要mock的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// doer/doer.go</span><br><br><span class="hljs-keyword">type</span> Doer <span class="hljs-keyword">interface</span> &#123; <br>  DoSomething(<span class="hljs-type">int</span>, <span class="hljs-type">string</span>) <span class="hljs-type">error</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>要测试的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user/user.go</span><br><br><span class="hljs-keyword">package</span> user<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/sgreben/testing-with-gomock/doer&quot;</span><br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123; <br>  Doer doer.Doer <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> Use() <span class="hljs-type">error</span> &#123; <br>  <span class="hljs-keyword">return</span> u.Doer.DoSomething(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;Hello GoMock&quot;</span>) <br>&#125;<br></code></pre></td></tr></table></figure><p>当前项目布局：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#x27;-- doer<br>    &#x27;-- doer.go<br>&#x27;-- user<br>    &#x27;-- user.go<br></code></pre></td></tr></table></figure><p><strong>第一步</strong>：</p><p>现在要将<code>Doer</code>的mock代码文件放在项目根目录下的mocks目录下，并且<code>User</code>的测试代码放在user&#x2F;user_test.go下：</p><p>首先创建mocks目录：<code>mkdir mocks</code></p><p>然后使用mogen命令生成<code>Doer</code>的mock代码：</p><p><code>mockgen -destination=mocks/mock_doer.go -package=mocks github.com/sgreben/testing-with-gomock/doer Doer</code></p><p>​    各参数的意义如下：</p><ul><li><code>-destination=mocks/mock_doer.go</code>: put the generated mocks in the file <code>mocks/mock_doer.go</code>.</li><li><code>-package=mocks</code>: put the generated mocks in the package <code>mocks</code></li><li><code>github.com/sgreben/testing-with-gomock/doer</code>: generate mocks for this package</li><li><code>Doer</code>: generate mocks for this interface. This argument is required — we need to specify the interfaces to generate mocks for explicitly. We <em>can</em>, however specify multiple interfaces here as a comma-separated list (e.g. <code>Doer1,Doer2</code>).</li></ul><blockquote><p>mock有两种操作模式：source 和 reflect，区别在于指定mock源的方式不同，source模式通过参数<code>-source</code>指明接口文件，reflect模式则就是上面所示的模式，通过包名+接口名指定要mock的接口</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#x27;-- doer<br>    &#x27;-- doer.go<br>&#x27;-- mocks<br>    &#x27;-- mock_doer.go<br>&#x27;-- user<br>    &#x27;-- user.go<br>    &#x27;-- user_test.go<br></code></pre></td></tr></table></figure><p><strong>第二步</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user/user_test.go</span><br><br>mockCtrl := gomock.NewController(t)<br><span class="hljs-keyword">defer</span> mockCtrl.Finish()<br><br>mockDoer := mocks.NewMockDoer(mockCtrl)<br></code></pre></td></tr></table></figure><p><strong>第三&amp;四步</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user/user_test.go</span><br><br><span class="hljs-keyword">package</span> user_test<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;github.com/sgreben/testing-with-gomock/mocks&quot;</span><br>  <span class="hljs-string">&quot;github.com/sgreben/testing-with-gomock/user&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUse</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    mockCtrl := gomock.NewController(t)<br>    <span class="hljs-keyword">defer</span> mockCtrl.Finish()<br><br>    mockDoer := mocks.NewMockDoer(mockCtrl)<br>    testUser := &amp;user.User&#123;Doer:mockDoer&#125;<br><br>    <span class="hljs-comment">// Expect Do to be called once with 123 and &quot;Hello GoMock&quot; as parameters, and return nil from the mocked call.</span><br>    mockDoer.EXPECT().DoSomething(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;Hello GoMock&quot;</span>).Return(<span class="hljs-literal">nil</span>).Times(<span class="hljs-number">1</span>)<br><br>    testUser.Use()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Using-GoMock-with-go-generate"><a href="#Using-GoMock-with-go-generate" class="headerlink" title="Using GoMock with go:generate"></a>Using <em>GoMock</em> with <code>go:generate</code></h3><p>如果有很多的包中的接口需要被mock的话，那么对每个包中的接口运行<code>mockgen</code>命令就有点繁琐了。为了改善这个问题，可以通过在测试文件中加上<code>//go:generate xxx</code>注释来解决（注意：&#x2F;&#x2F;和go:generate之间没有空格）。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// doer/doer.go</span><br><br><span class="hljs-keyword">package</span> doer<br><br><span class="hljs-comment">//go:generate mockgen -destination=../mocks/mock_doer.go -package=mocks github.com/sgreben/testing-with-gomock/doer Doer</span><br><br><span class="hljs-keyword">type</span> Doer <span class="hljs-keyword">interface</span> &#123;<br>    DoSomething(<span class="hljs-type">int</span>, <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当要运行所有的<code>mockgen</code>命令时，可以在项目根目录下执行<code>go generate ./...</code>命令。</p><h3 id="Using-argument-matchers"><a href="#Using-argument-matchers" class="headerlink" title="Using argument matchers"></a>Using argument matchers</h3><p>有时候我们不太关系mock的接口的方法被调用时传入的参数，此时可以在设置被mock的接口的方法时传入匹配器，gomock中定义了如下的匹配器：</p><ul><li><code>gomock.Any()</code>: matches any value (of any type)</li><li><code>gomock.Eq(x)</code>: uses reflection to match values that are <code>DeepEqual</code> to <code>x</code></li><li><code>gomock.Nil()</code>: matches <code>nil</code></li><li><code>gomock.Not(m)</code>: (where <code>m</code> is a Matcher) matches values not matched by the matcher <code>m</code></li><li><code>gomock.Not(x)</code>: (where <code>x</code> is <em>not</em> a Matcher) matches values not <code>DeepEqual</code> to <code>x</code></li></ul><p>例如：<code>mockDoer.EXPECT().DoSomething(gomock.Any(), gomock.Eq(&quot;Hello GoMock&quot;))</code></p><h3 id="Asserting-call-order"><a href="#Asserting-call-order" class="headerlink" title="Asserting call order"></a>Asserting call order</h3><p>gomock提供了<code>.After()</code>函数来设置预期行为的调用顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">callFirst := mockDoer.EXPECT().DoSomething(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;first this&quot;</span>)<br>callA := mockDoer.EXPECT().DoSomething(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;then this&quot;</span>).After(callFirst)<br>callB := mockDoer.EXPECT().DoSomething(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;or this&quot;</span>).After(callFirst)<br><span class="hljs-comment">// callFirst must occur before either callA or callB.</span><br></code></pre></td></tr></table></figure><p>gomock还提供了 <code>gomock.InOrder()</code> 来设置预期行为的严格的调用顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">gomock.InOrder(<br>    mockDoer.EXPECT().DoSomething(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;first this&quot;</span>),<br>    mockDoer.EXPECT().DoSomething(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;then this&quot;</span>),<br>    mockDoer.EXPECT().DoSomething(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;then this&quot;</span>),<br>    mockDoer.EXPECT().DoSomething(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;finally this&quot;</span>),<br>)<br></code></pre></td></tr></table></figure><h3 id="Specifying-mock-actions"><a href="#Specifying-mock-actions" class="headerlink" title="Specifying mock actions"></a>Specifying mock actions</h3><p>gomock设置的预期行为通常是不做什么事情的，通常只接受参数、设定返回值、设定调用次数等就结束了。如果想要预期行为做一些事情，可以通过<code>.Do()</code>来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">mockDoer.EXPECT().<br>    DoSomething(gomock.Any(), gomock.Any()).<br>    Return(<span class="hljs-literal">nil</span>).<br>    Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">string</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> x &gt; <span class="hljs-built_in">len</span>(y) &#123;<br>            t.Fail()<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="常用的mock方法"><a href="#常用的mock方法" class="headerlink" title="常用的mock方法"></a>常用的mock方法</h3><ul><li>Call.Do()：声明在匹配时要运行的操作</li><li>Call.DoAndReturn()：声明在匹配调用时要运行的操作，并且模拟返回该函数的返回值</li><li>Call.MaxTimes()：设置最大的调用次数为 n 次</li><li>Call.MinTimes()：设置最小的调用次数为 n 次</li><li>Call.AnyTimes()：允许调用次数为 0 次或更多次</li><li>Call.Times()：设置调用次数为 n 次</li></ul><h2 id="Gomonkey"><a href="#Gomonkey" class="headerlink" title="Gomonkey"></a>Gomonkey</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>gomonkey是一个专门用以打桩（桩代码：指用来代替关联代码或者未实现代码的代码）的第三方库(<a href="https://github.com/agiledragon/gomonkey)%EF%BC%8C%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BD%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%8D%81%E5%88%86%E5%BC%BA%E5%A4%A7%EF%BC%8Cgomonkey%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E4%BB%A5%E4%B8%8B%E5%8A%9F%E8%83%BD%EF%BC%9A">https://github.com/agiledragon/gomonkey)，接口设计良好，功能十分强大，gomonkey可以为我们提供以下功能：</a></p><ul><li>为一个函数打一个桩</li><li>为一个成员方法打一个桩</li><li>为一个全局变量打一个桩</li><li>为一个函数变量打一个桩</li><li>为一个接口打一个桩</li><li>为一个函数打一个特定的桩序列</li><li>为一个成员方法打一个特定的桩序列</li><li>为一个函数变量打一个特定的桩序列</li><li>为一个接口打一个特定的桩序列</li></ul><p><strong>打桩的原理就是在运行时通过二进制指令改写可执行程序，将对目标函数或方法的成员跳转到桩的实现。</strong></p><h3 id="与GoMock比较"><a href="#与GoMock比较" class="headerlink" title="与GoMock比较"></a>与GoMock比较</h3><ol><li>gomonkey支持任何场景的打桩，而gomock仅支持对interface的打桩</li><li>gomonkey的使用不需要通过工具来生成桩代码</li><li>gomonkey是通过在运行时改写可执行程序来改变调用目标的，而gomock则是先生成桩代码，然后直接去调用桩代码来实现mock，也就是在编译期间</li><li>gomonkey1.0支持的关键字比gomock少很多，不过2.0增加了许多扩充（dsl库）</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>如果启用了内联函数的话（go编译器默认启用），gomonkey将无法成功对函数或成员方法进行打桩，应该需要在运行<code>go test</code>的时候加上<code>-gcflags=-l</code>（go1.10以下）或<code>-gcflags=all=-l</code>（go1.10以上）</li><li>gomonkey仅支持amd64架构的系统</li><li>当正在被打桩的函数或成员方法在同一时间对其他goroutine可见时，将会引发<code>panic</code>异常，也就是说，gomonkey不是线程安全的</li><li>由于go1.7及以上之后，就不再能通过反射机制来获取私有成员方法，因此，在go1.7及以上版本中，gomonkey无法为私有成员方法进行打桩，但私有函数还是可以的</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span> <br>go <span class="hljs-built_in">test</span> -gcflags=all=-l<br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><a href="https://github.com/agiledragon/gomonkey/tree/master/test">https://github.com/agiledragon/gomonkey/tree/master/test</a></p><h1 id="使用pprof进行性能调优"><a href="#使用pprof进行性能调优" class="headerlink" title="使用pprof进行性能调优"></a>使用pprof进行性能调优</h1><p>性能调优的一般步骤：</p><p>1.使用<code>go test -bench . -cpuprofile cpu.out</code>获取性能数据文件cpu.out</p><p>2.使用<code>go tool pprof cpu.out</code>查看性能数据</p><p>3.分析慢在哪里</p><p>4.优化代码。然后继续第一步。</p><p><strong>注意：</strong>在第二步查看性能数据时键入上述命令行会进入pprof交互程序，此时可以输入<code>web</code>进行可视化查看性能数据。但首先得安装graphviz这个工具，在<a href="https://graphviz.org/download/%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E5%AE%89%E8%A3%85%E3%80%82">https://graphviz.org/download/这个网站可以安装。</a></p><h1 id="使用go-doc查看文档"><a href="#使用go-doc查看文档" class="headerlink" title="使用go doc查看文档"></a>使用go doc查看文档</h1><p><code>go help doc</code>查看go doc相关参数</p><p><code>go doc [fmt.Println]</code>可以在Terminal查看文档</p><p><code>godoc -http :6060</code>可以在浏览器输入localhost:6060来查看文档。<strong>godoc命令是生成文档；go doc命令是查看文档。如果在项目中写了注释或者示例代码，那么在godoc生成的文档中都可以查看的到。</strong></p><p>安装godoc：go get golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;godoc</p><h1 id="使用for-range的注意事项"><a href="#使用for-range的注意事项" class="headerlink" title="使用for range的注意事项"></a>使用for range的注意事项</h1><p><strong>range表达式只会在for语句开始执行时被求值一次，求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本，而不会原值。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>number2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>maxIndex := <span class="hljs-built_in">len</span>(number2) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> number2 &#123;<br><span class="hljs-keyword">if</span> i == maxIndex &#123;<br>number2[<span class="hljs-number">0</span>] += e<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>number2[i+<span class="hljs-number">1</span>] += e<br>&#125;<br>&#125;<br>fmt.Println(number2)<br>&#125;<br><span class="hljs-comment">//输出：22,3,6,10,15,21</span><br></code></pre></td></tr></table></figure><p>而如果将number2的切片改为数组，则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>number2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>maxIndex := <span class="hljs-built_in">len</span>(number2) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> number2 &#123;<br><span class="hljs-keyword">if</span> i == maxIndex &#123;<br>number2[<span class="hljs-number">0</span>] += e<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>number2[i+<span class="hljs-number">1</span>] += e<br>&#125;<br>&#125;<br>fmt.Println(number2)<br>&#125;<br><span class="hljs-comment">//输出：7,3,5,7,9,11</span><br></code></pre></td></tr></table></figure><p><strong>这是因为数组发生复制，新的数组和旧的数组就没有关系了；而切片是引用类型，发生复制后底层还是同样的数据。</strong></p><h2 id="使用for-range遍历字符串"><a href="#使用for-range遍历字符串" class="headerlink" title="使用for range遍历字符串"></a>使用for range遍历字符串</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;Go爱好者 &quot;</span><br><span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> str &#123;<br> fmt.Printf(<span class="hljs-string">&quot;%d: %q [% x]\n&quot;</span>, i, c, []<span class="hljs-type">byte</span>(<span class="hljs-type">string</span>(c)))<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//0: &#x27;G&#x27; [47]</span><br><span class="hljs-comment">//1: &#x27;o&#x27; [6f]</span><br><span class="hljs-comment">//2: &#x27;爱&#x27; [e7 88 b1]</span><br><span class="hljs-comment">//5: &#x27;好&#x27; [e5 a5 bd]  注意这里的索引值是5，而不是3</span><br><span class="hljs-comment">//8: &#x27;者&#x27; [e8 80 85]  注意这里的索引值是8，而不是4</span><br></code></pre></td></tr></table></figure><p>for range语句遍历字符串会先将字符串拆分成一个字节序列，然后再试图找出这个字节序列中包含的每一个UTF-8编码值，或者说每一个unicode字符。</p><p>如果存在两个迭代变量（上面代码中的<code>i</code>和<code>c</code>），那么第一个变量值是当前字节序列中某个UTF-8编码值的第一个字节的索引值，第二个变量则是这个UTF-8编码值对应的unicode字符，类型是rune。</p><h1 id="数组、字符串和切片"><a href="#数组、字符串和切片" class="headerlink" title="数组、字符串和切片"></a>数组、字符串和切片</h1><p><a href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch1-basic/ch1-03-array-string-and-slice.html">https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch1-basic/ch1-03-array-string-and-slice.html</a></p><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><ol><li>数组的类型由数组的长度和数组中元素的类型这两部分决定。</li><li>go语言中数组是值语义的，一个数组变量即表示整个数组，并不是像c语言那样隐式地指向第一个元素的指针。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。</li><li>如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>一个字符串是一个<strong>不可改变</strong>的<strong>字节序列</strong>。和数组不同的是，字符串的元素不可更改，是一个只读的字节数组。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。</p></li><li><p>Go语言字符串的底层结构在<code>reflect.StringHeader</code>中定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。字符串其实是一个结构体，因此字符串的赋值操作也就是<code>reflect.StringHeader</code>结构体的复制过程，并不会涉及底层字节数组的复制。</p></li><li><p>字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串字面值通常是对应同一个字符串常量）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello, world&quot;</span><br>hello := s[:<span class="hljs-number">5</span>]<br>world := s[<span class="hljs-number">7</span>:]<br><br>s1 := <span class="hljs-string">&quot;hello, world&quot;</span>[:<span class="hljs-number">5</span>]<br>s2 := <span class="hljs-string">&quot;hello, world&quot;</span>[<span class="hljs-number">7</span>:]<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>以上五个变量都是string类型，没有切片类型。</p></li><li><p>Go语言还支持字符串和<code>[]rune</code>类型间相互转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, []<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;世界&quot;</span>))              <span class="hljs-comment">// []int32&#123;19990, 30028&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, <span class="hljs-type">string</span>([]<span class="hljs-type">rune</span>&#123;<span class="hljs-string">&#x27;世&#x27;</span>, <span class="hljs-string">&#x27;界&#x27;</span>&#125;)) <span class="hljs-comment">// 世界</span><br></code></pre></td></tr></table></figure><p>字符串相关的强制类型转换主要涉及到<code>[]byte</code>和<code>[]rune</code>两种类型。不过字符串和<code>[]rune</code>的转换要更为特殊一些，因为它们底层对应的<code>[]byte</code>和<code>[]int32</code>类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。</p></li><li><p>下面分别用伪代码简单模拟Go语言对字符串内置的一些操作，这样对每个操作的处理的时间复杂度和空间复杂度都会有较明确的认识：</p></li><li><p><strong>遍历字符串</strong></p><p>使用下标遍历字符串返回的是[]byte中的某个元素，使用for range遍历字符串返回的是rune类型。此外可以这样判断字符串中某元素是否等于某字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-string">&quot;abc&quot;</span><br>b := a[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> b == <span class="hljs-string">&#x27;a&#x27;</span> &#123; <span class="hljs-comment">// 成立，此时&#x27;a&#x27;自动转为uint8类型</span><br>&#125;<br><br>c := <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">if</span> b == c &#123; <span class="hljs-comment">// 语法错误，此时c为int32类型</span><br>  <br>&#125;<br><br><span class="hljs-comment">// 单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="for-range对字符串的迭代模拟实现"><a href="#for-range对字符串的迭代模拟实现" class="headerlink" title="for range对字符串的迭代模拟实现"></a>for range对字符串的迭代模拟实现</h3><p><strong><code>for range</code>对字符串的迭代模拟实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forOnString</span><span class="hljs-params">(s <span class="hljs-type">string</span>, forBody <span class="hljs-keyword">func</span>(i <span class="hljs-type">int</span>, r <span class="hljs-type">rune</span>)</span></span>) &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span>; &#123;<br>        r, size := utf8.DecodeRuneInString(s)<br>        forBody(i, r)<br>        s = s[size:]<br>        i += size<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for range</code>迭代字符串时，每次解码一个Unicode字符，然后进入<code>for</code>循环体，遇到崩坏的编码并不会导致迭代停止。</p><h3 id="byte和string的转换的模拟实现"><a href="#byte和string的转换的模拟实现" class="headerlink" title="[]byte和string的转换的模拟实现"></a>[]byte和string的转换的模拟实现</h3><p><strong><code>[]byte(s)</code>转换模拟实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">str2bytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        c := s[i]<br>        p[i] = c<br>    &#125;<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟实现中新创建了一个切片，然后将字符串的数组逐一复制到了切片中，这是为了保证字符串只读的语义。当然，在将字符串转为<code>[]byte</code>时，如果转换后的变量并没有被修改的情形，编译器可能会直接返回原始的字符串对应的底层数据。</p><p><strong><code>string(bytes)</code>转换模拟实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytes2str</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> (p <span class="hljs-type">string</span>) &#123;<br>    data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;<br>        data[i] = c<br>    &#125;<br><br>    hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;p))<br>    hdr.Data = <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;data[<span class="hljs-number">0</span>]))<br>    hdr.Len = <span class="hljs-built_in">len</span>(s)<br><br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Go语言的字符串是只读的，无法直接同构构造底层字节数组生成字符串。在模拟实现中通过<code>unsafe</code>包获取了字符串的底层数据结构，然后将切片的数据逐一复制到了字符串中，这同样是为了保证字符串只读的语义不会受切片的影响。如果转换后的字符串在生命周期中原始的<code>[]byte</code>的变量并不会发生变化，编译器可能会直接基于<code>[]byte</code>底层的数据构建字符串。</p><h3 id="rune和string的转换的模拟实现"><a href="#rune和string的转换的模拟实现" class="headerlink" title="[]rune和string的转换的模拟实现"></a>[]rune和string的转换的模拟实现</h3><p><strong><code>[]rune(s)</code>转换模拟实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">str2runes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">rune</span>&#123;<br>    <span class="hljs-keyword">var</span> p []<span class="hljs-type">int32</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s)&gt;<span class="hljs-number">0</span> &#123;<br>        r,size:=utf8.DecodeRuneInString(s)<br>        p=<span class="hljs-built_in">append</span>(p,<span class="hljs-type">int32</span>(r))<br>        s=s[size:]<br>        &#125;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">rune</span>(p)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为底层内存结构的差异，字符串到<code>[]rune</code>的转换必然会导致重新分配<code>[]rune</code>内存空间，然后依次解码并复制对应的Unicode码点值。这种强制转换并不存在前面提到的字符串和字节切片转化时的优化情况。</p><p><strong><code>string(runes)</code>转换模拟实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runes2string</span><span class="hljs-params">(s []<span class="hljs-type">int32</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> p []<span class="hljs-type">byte</span><br>    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<br>        n := utf8.EncodeRune(buf, r)<br>        p = <span class="hljs-built_in">append</span>(p, buf[:n]...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(p)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样因为底层内存结构的差异，<code>[]rune</code>到字符串的转换也必然会导致重新构造字符串。这种强制转换并不存在前面提到的优化情况。</p><h2 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h2><ol><li><p>切片的结构定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>    Cap  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>切片可以和<code>nil</code>进行比较，只有当切片底层数据指针为空时切片本身为<code>nil</code>，这时候切片的长度和容量信息将是无效的。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了（比如直接通过<code>reflect.SliceHeader</code>或<code>unsafe</code>包对切片作了不正确的修改）。</p></li><li><p>切片的定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a []<span class="hljs-type">int</span>               <span class="hljs-comment">// nil切片, 和 nil 相等, 一般用来表示一个不存在的切片</span><br>    b = []<span class="hljs-type">int</span>&#123;&#125;           <span class="hljs-comment">// 空切片, 和 nil 不相等, 一般用来表示一个空的集合</span><br>    c = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;    <span class="hljs-comment">// 有3个元素的切片, len和cap都为3</span><br>    d = c[:<span class="hljs-number">2</span>]             <span class="hljs-comment">// 有2个元素的切片, len为2, cap为3</span><br>    e = c[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>:<span class="hljs-built_in">cap</span>(c)]     <span class="hljs-comment">// 有2个元素的切片, len为2, cap为3</span><br>    f = c[:<span class="hljs-number">0</span>]             <span class="hljs-comment">// 有0个元素的切片, len为0, cap为3</span><br>    g = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)    <span class="hljs-comment">// 有3个元素的切片, len和cap都为3</span><br>    h = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 有2个元素的切片, len为2, cap为3</span><br>    i = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 有0个元素的切片, len为0, cap为3</span><br>)<br></code></pre></td></tr></table></figure></li></ol><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>GC的目的是为了实现垃圾回收，主要的过程是内存标记和内存回收。标记过程采用三色标记法大致过程：</p><p>首先所有内存节点都是白色的，然后将可达节点不断的置灰和置黑，最终还是白色的节点就是可回收的内存。</p><p>但是在标记过程中不允许修改这些内存节点的引用，所以需要STW。如果想要并发标记（就是一边标记一边执行程序）需要写屏障技术（和内存写屏障不是一回事）。</p><p>写屏障就是在更改指针内容前执行一小段代码，这段代码是go在编译时增加的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">*slot = ptr  <span class="hljs-comment">// 如果ptr这个对象之前是白色的，那么在执行这行代码前会将其置灰</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/blini/blog_picture/raw/master/img/image-20220608155703724.png" alt="image-20220608155703724"></p><h2 id="gc触发时间点"><a href="#gc触发时间点" class="headerlink" title="gc触发时间点"></a>gc触发时间点</h2><ol><li>gcTriggerHeap：当前已分配内存与上次GC结束后存活对象的内存达到某个比例时（一般是2倍）触发。</li><li>gcTriggerTime：sysmon检测2min内是否运行过gc，没有的话就触发gc。</li><li>gcTriggerAlways：runtime.GC()强制触发gc。</li></ol><h1 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h1><h2 id="GM-gt-GMP"><a href="#GM-gt-GMP" class="headerlink" title="GM-&gt;GMP"></a>GM-&gt;GMP</h2><p>最容易想到的是一个协程一个线程，但是很显然不行，当协程数增多时，线程的创建、销毁、切换开销无法承受。</p><p>然后可以想到用一个线程池，N个协程，M个线程，所有的协程放入一个全局队列中，由线程主动获取协程来运行。这就是golang1.0中N:M的GM调度模型，那这种方式有什么问题呢？</p><ul><li>锁竞争问题：所有线程要竞争一把全局队列的锁，会引起很大的调度延迟问题</li><li>内存亲和性不好：比如协程A创建协程B，大概率B会被其他的M执行。内存亲和性也可以理解为空间局部性</li><li>内存浪费问题：每个线程会使用一定的memory cache（比如sync.Pool对象）和stack cache，并且当该线程处于系统调用阻塞状态时，这些被占用的内存是没有用到的，只有在运行协程时才需要用到。如果处于系统调用阻塞状态的线程增多时，会有很大的内存浪费。一般而言，正在被允许的线程和处于阻塞的线程数量比可以达到1：100</li></ul><p>为了解决上述问题，可以想到将全局队列拆分为多个本地队列，个数为CPU核数，也就是最大的线程并行数。这种方式可以解决问题1、2，但是解决不了问题3，因为线程还是和内存资源绑定一起的。于是就要祭出计算机中的银弹了—-加一个中间层P，P这一层可以理解为资源层，协程本地队列和线程的内存资源都在这一层。当一个线程阻塞时，只需要将其与P解绑，然后调入一个空闲线程过来就可以继续运行；当线程恢复阻塞时，就加入空闲线程队列，等待下次被调入。</p><blockquote><p>注意：将全局队列拆分为多个本地队列的思想是解决并发竞争问题的一个很好的方法。解决竞争问题往往不是考虑什么lock free，而是数据分治和逻辑分治。数据分治就是将全局的改为多个本地的，一个线程负责一个本地的，从而减少竞争粒度；逻辑分治我理解为是将锁粒度变小，比如由原来锁住一整个函数变为锁住该函数中一部分逻辑。</p></blockquote><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>go调度器的职责就是为需要运行的G寻找执行者M和执行的资源P。</p><p>调度的时机有：</p><ol><li>协程阻塞：比如channel、mutex等sync操作</li><li>time.sleep</li><li>网络操作暂未ready</li><li>gc</li><li>主动yield</li><li>运行过久或者系统调用</li><li>等等</li></ol><h3 id="sysmon协程"><a href="#sysmon协程" class="headerlink" title="sysmon协程"></a>sysmon协程</h3><p>sysmon协程是在执行用户代码前，由runtime启动的不与任何P绑定的，直接由一个M指向的协程。类似linux中的执行一些系统任务的内核线程。</p><p>sysmon协程的功能比较多，比如：定时从netpoll中获取ready的协程、进行抢占、定时GC、归还内存等等。</p><p>当一个协程运行太久会影响对其他协程的调用，因此sysmon的一个任务就是对运行过久的协程进行抢占。并且当协程进行系统调用过久的话，sysmon协程还会将这个协程的P和M进行分离，目的都是为了防止P被占用过久，影响调度。总的来说，就是当协程无法主动发生调度并且又占用时间过长的话，对该协程调度的任务就需要由sysmon协程来进行了。</p><p>sysmon协程可以理解为10ms执行一次，是一个无线循环的函数。实际上其初始执行间隔时间是20us、运行1ms后逐渐翻倍，最终每10ms运行一次。如果发生抢占成功，则又恢复成20us一次，如此循环。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>new一个对象首先是调用newObject函数，最终都是调用mallocgc来分配内存。</p><p>总的过程：</p><ol><li><p>如果分配对象的size是0，那么直接返回一个特征的全局变量zerobase</p></li><li><p>如果分配对象的size小于16字节并且是无指针的，那么直接在每个P的tiny分配器中进行分配。</p></li><li><p>如果分配对象的size是16字节~32KB之间，则从当前P中的mcache中分配，mcache中67*2（*2是代表有指针对象和无指针对象；67个代表不同size的mspan）个mspan，以及一个tiny分配器，还有栈内存分配cache。如果当前P中的mcache中的mspan都用完了，则从该size的mspan的后备mcentral中分配一个mspan；如果也没有了，则从全局唯一的mheap中进行分配；如果还是没有，就扩大堆内存（mmap&#x2F;sbrk）</p><p><img src="https://gitee.com/blini/blog_picture/raw/master/img/image-20220609020116186.png" alt="image-20220609020116186"></p><blockquote><p>mcache是每个P独有的，所以每个G在mcache中进行内存的申请和释放都是无锁的；mcentral是所有P共享的，所以需要加锁，但是由于进行了数据分治，因此锁粒度较小；mheap是全局唯一的，对其操作需要加锁。</p></blockquote></li><li><p>如果分配对象的size大于32KB，则直接调用mheap中分配，如果内存不够，则调用mmap&#x2F;sbrk申请堆内存。</p><p><img src="https://gitee.com/blini/blog_picture/raw/master/img/image-20220609020051502.png" alt="image-20220609020051502"></p></li></ol><p>内存管理总体上类似TCMalloc，同时golang也做了一些优化：</p><ol><li>0size对象共用一个全局对象，小对象采用tiny分配器</li><li>每个P有不同size的mspan，可以无锁管理，同时也优化内存碎片</li><li>mheap采用类似伙伴分配器的方式管理空闲页，进行页的分配和合并</li></ol><p><img src="https://gitee.com/blini/blog_picture/raw/master/img/image-20220701145339233.png" alt="image-20220701145339233"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>go语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/09/hello-world/"/>
    <url>/2022/07/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
